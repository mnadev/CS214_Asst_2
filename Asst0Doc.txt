SIMPLECSVSORTER.C
simpleCSVsorter is a program that given a csv and a category sorts the csv file by that specific category.
SYNOPSIS
  simpleCSVsorter.out -c <ColumnToSortBy>
DESCRIPTION
  simpleCSVsorter reads in a CSV file by filename. Then, the CSV file is sorted by the given parameter and the output is printed to stdout.  
OPTIONS
  "-c" indicates that the sorting of data entries is to be done based on columns
  <ColumnToSortBy> is the name of the column that the program is to sort by.
EXAMPLES

EXIT STATUS
The code will return 0 if terminated successfully. The code will return -1 if the command line arguments are not correct or if there are insufficient arguments. The program will also return -1 if the row that was to be sorted doesn't exist inside the CSV file.
SEE ALSO
simplecsvsorter.h
mergesort.c
BUGS
None currently known.
AUTHOR(s)
Eric Lin and Mohammad Nadeem

The design of the program is as follows:
	Before the CSV is actually parsed, the program will check the arguments to ensure that the arguments were properly inputted, outputting to STDERR and returning -1 if the arguments did not match the required format.
	In the first part of the program, the program allocates 500 bytes to be used as a buffer to store the row containing the names of the columns. Characters are then read in one by one from the STDIN file descriptor to the buffer until a newline character '\n' is found, counting the number of characters that are being read in. The assumption is made that the row containing column names will contain less than 500 bytes, as the given test CSV only has around 410 characters in the first row. Once '\n' is found, the program reduces the size of the buffer to the exact space needed to hold all the characters, and searches for the input <ColumnToSortBy>. If not found, the program returns -1. If found, the program counts the number of commas before the <ColumnToSortBy> substring. Each following row then counts the number of commas parsed. When the number of commas parsed is lower than the number of commas before the sorted column, the characters are placed into the beforeSortedCol field of the movieInfo struct. When the number of commas parsed is equal to the number of commas before the sorted column, the characters are placed into the toBeSorted field, and when the number of commas parsed is greater than the number of commas before the sorted column, the characters are placed in the afterSortedCol field. The pointer referring to the movieInfo struct is put into an array of movieInfo pointers, and this is passed into mergesort to be sorted.


SIMPLECSVSORTER.H
SYNOPSIS
simpleCSVsorter.h is a header file that defines necessary structs and functions required for the CSV sorter to operate.
OPTIONS

EXAMPLES

EXIT STATUS
Since this is a header file, exit status is not defined and not necessary for function of the code.
SEE ALSO
simpleCSVsorter.c
mergesort.c
BUGS
None currently known.
AUTHOR(s)
Eric Lin and Mohammad Nadeem


This header file defines the struct movieInfo which has threechar * fields and three int fields. The first field called beforeSortedCol holds all of the data before the sorted column. The second field called toBeSorted holds the column that we will sort. The third field called afterSortedCol holds all of the data after the sorted column. The three int fields hold the number of characters in each of the char* fields. This header file also describes the mergesort function so that it can be used in simpleCSVsorter.c. 

MERGESORT.C
SYNOPSIS
mergesort.c takes in a an array of movieInfo and then performs mergesort on the array in question given a certain parameter.
DESCRIPTION
void mergesort(movieInfo** arr, int left, int right, int isInt)
void swap(movieInfo* A, movieInfo* B)
float intComparison(float intA, float intB)
void merge(movieInfo** arr, int left, int half, int right, int isInt)
EXIT STATUS
Mergesort does not return a value. It sorts the array using pointers. 
SEE ALSO
simpleCSVsorter.c
simpleCSVsorter.h
BUGS
None currently known.
AUTHOR(s)
Eric Lin and Mohammad Nadeem

For mergesort, there are 4 parameters needed to run mergesort. The first is, trivially, the array in question that must be sorted. Mergesort also requires the left index and the right index of the (sub)array being sorted. The last parameter that mergesort takes is call isInt. isInt lets the program know if the data is numeric or alphabetic. If isInt is of value 0, then the data is alphabetic and must be sorted as such. If isInt is of value 1, then the data is numeric and must be sorted as such. For mergesort, the array is halved continously until the base case of an array of one element is reached. Then, each subarray is merged. To merge, the merge function is called. In merge, the two subarrays are written to temporary arrays. Two pointers point to the leftmost indices of both subarrays and whichever value is less is written to the actual array in which we will add our sorted values. The base case for merge is when both subarrays are the same array or when there is only one element in each subarray. In the case where there is only one element in each subarray, the values are swapped if they are out of order.  
	In mergesort.c, there exists a comparator function that is useful for comparing numeric values. The necessity for this was because strcmp does not correctly compare strings that represent numeric values. 

EXTRA CREDIT
Regarding sorting the CSV, the struct that we created has been designed such as to allow any CSV to be sorted given a category. The struct only holds three pieces of data, the characters before the sorted column, the string in the sorted column and the characters after the sorted column. As a result, this program has been generally designed to allow for any CSV input and a given column name, and the CSV will be sorted by the given column. If anything, the initial size of the buffers used to parse in the CSV can be enlarged to accomodate CSVs with more columns.

ISSUES
In creating this program, a number of issues arose. First and foremost, there were a lot of issues with segmentation faults. The primary reason for most of the segmentation faults was the fact that a pointer was left pointing to an arbitrary value when iterated because the iteration was uncontrolled. There were a lot of issues with creating merge sort. The initial algorithm took some time to program. However, afterwards, a number of issues arose. First, there was no base case in the merge function resulting in the arrays not being sorted
correctly. There was also an issue in the swap function which led to swap acting as a copy function because it copied data from one pointer to another rather than swapping. There was also an issue with isInt which was a result of faulty logic in the conditional statements. 
	There was an issue we came across when writing to stdout. The issue was that the size of the char arrays was unknown so we assumed it to be 500 and wrote 500 bytes to stdout. However, mostof the strings were less than 500 bytes, and thus when we wrote 500 bytes to stdout, alot of random bits of memory were also written to stdout. To remedy this, we just calculate the length of each string as we read it and stored it in a variable. Thus, when we wrote back to stdout, we would know how many bytes to write. 


TESTING
See the attached csv files for test cases. 
